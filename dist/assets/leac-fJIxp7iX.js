const b=/\n/g;function E(e){const t=[...e.matchAll(b)].map(s=>s.index||0);t.unshift(-1);const n=h(t,0,t.length);return s=>x(n,s)}function h(e,t,n){if(n-t==1)return{offset:e[t],index:t+1};const s=Math.ceil((t+n)/2),i=h(e,t,s),u=h(e,s,n);return{offset:i.offset,low:i,high:u}}function x(e,t){return function(n){return Object.prototype.hasOwnProperty.call(n,"index")}(e)?{line:e.index,column:t-e.offset}:x(e.high.offset<t?e.high:e.low,t)}function k(e,t="",n={}){const s=typeof t!="string"?t:n,i=typeof t=="string"?t:"",u=e.map(R),w=!!s.lineNumbers;return function(l,m=0){const y=w?E(l):()=>({line:0,column:0});let o=m;const a=[];e:for(;o<l.length;){let p=!1;for(const r of u){r.regex.lastIndex=o;const c=r.regex.exec(l);if(c&&c[0].length>0){if(!r.discard){const f=y(o),d=typeof r.replace=="string"?c[0].replace(new RegExp(r.regex.source,r.regex.flags),r.replace):c[0];a.push({state:i,name:r.name,text:d,offset:o,len:c[0].length,line:f.line,column:f.column})}if(o=r.regex.lastIndex,p=!0,r.push){const f=r.push(l,o);a.push(...f.tokens),o=f.offset}if(r.pop)break e;break}}if(!p)break}return{tokens:a,offset:o,complete:l.length<=o}}}function R(e,t){return{...e,regex:$(e,t)}}function $(e,t){if(e.name.length===0)throw new Error(`Rule #${t} has empty name, which is not allowed.`);if(function(n){return Object.prototype.hasOwnProperty.call(n,"regex")}(e))return function(n){if(n.global)throw new Error(`Regular expression /${n.source}/${n.flags} contains the global flag, which is not allowed.`);return n.sticky?n:new RegExp(n.source,n.flags+"y")}(e.regex);if(function(n){return Object.prototype.hasOwnProperty.call(n,"str")}(e)){if(e.str.length===0)throw new Error(`Rule #${t} ("${e.name}") has empty "str" property, which is not allowed.`);return new RegExp(g(e.str),"y")}return new RegExp(g(e.name),"y")}function g(e){return e.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g,"\\$&")}export{k as o};
